/**
 * Group Members: Christopher Meyer, Joey Johnson, Shane Blankenship
 * Project: Trees With Removal
 * Teacher: Mr. Meinzen
 * Class: AP Computer Science A
 * Date: 21 February 2024
 */

public class Tree implements BSTree
{
    private TreeNode myRoot;
 
    /**
     * constructor method for Tree()
     */
    public Tree() 
    {
      myRoot = null;
    } 
    
	/**
	 * 	removes a node with a given value
	 */
    public void remove(Comparable c) 
    {
    	if (c == null) {return;}
		remove(c, myRoot);
    }
    
    /**
     * private helper method to remove a node from the tree
     */
	private void remove(Comparable c, TreeNode t) 
	{
		//if a node with value c exists
		if(search(c) && t != null)
		{
			double v = valueOf(c);
			if(valueOf(c) == -2000000.0003467387) {return;}
			TreeNode temp = searchNode(c);
			TreeNode parent = searchParentNode(c);
			//if temp is myRoot
			if(searchParentNode(c) == null) 
			{
				//if temp has no branches set null
				if(temp.getLeft() == null && temp.getRight() == null)
				{
					myRoot = null; 
					return;
				}
				//if temp only has a branch on the left set 
				//that to myRoot
				else if(myRoot.getRight() == null)
				{
					temp = myRoot.getLeft();
					searchNode(c).setLeft(null);
					myRoot = temp;
				}
				//if temp only has a branch on the right set 
				//that to myRoot
				else if(myRoot.getLeft() == null)
				{
					temp = myRoot.getRight();
					searchNode(c).setRight(null);
					myRoot = temp;
				}
				//if neither left or right are null find the 
				//smallest value to the right and set its left
				//to the myRoot's left, then set myRoot to temp
				else
				{
					TreeNode l = getSmallest(temp.getRight());
					TreeNode smallestParent = 
							 searchParentNode(l.getValue());
					TreeNode left = myRoot.getLeft();
					TreeNode right = myRoot.getRight();
					//if the smallest node has a right child
					if(l.getRight() != null)
					{
						searchParentNode(l.getValue())
						                 .setLeft(l.getRight());
						l.setRight(null);
						searchNode(getSmallest(myRoot.getLeft())
								   .getValue()).setLeft(left);
						left = myRoot.getLeft();
						right = myRoot.getRight();
						myRoot.setRight(null);
						myRoot.setLeft(null);
						myRoot = null;
						l.setRight(right);
						l.setLeft(left);
						myRoot = l;
						
					}
					//if the smallest node does not have a right child
					else
					{
						if(searchParentNode(l.getValue()) == myRoot)
						{
							myRoot.setRight(null);
						}
						else
						{
							searchParentNode(l.getValue()).setLeft(null);
						}
						left = myRoot.getLeft();
						right = myRoot.getRight();
						l.setRight(right);
						l.setLeft(left);
						myRoot = null;
						myRoot = l;
					}
				}
					return;
			}
			//if temp is not myRoot and has both children
			else if(temp.getLeft() != null && temp.getRight() != null)
			{
				//get the smallest node on temp's right and its parent
				TreeNode a = searchNode(temp
						     .getValue()).getLeft();
				TreeNode l = getSmallest(temp.getRight());
				TreeNode smallestParent = 
						 searchParentNode(l.getValue());
				//if l has a right child
				if(l.getRight() != null)
				{
					if(a != null) 
					{
						//if temp is on the parent's left
						if(parent.getLeft() != null && valueOf(parent
						   .getLeft().getValue()) == v)
						{
							searchNode(l.getRight()
									   .getValue()).setLeft(a);
							searchNode(parent.getValue())
							           .setLeft(l);
							searchParentNode(l.getValue())
							                 .setLeft(l.getRight());
							searchNode(l.getValue())
							           .setRight(null);
						}
						//if temp is on the parent's right
						if(parent.getRight() != null && valueOf(parent
						   .getRight().getValue()) == v)
						{
							searchNode(l.getRight()
									    .getValue()).setLeft(a);
							searchNode(parent.getValue())
							           .setRight(l);
							searchParentNode(l.getValue())
							                 .setLeft(l.getRight());
							searchNode(l.getValue())
							           .setRight(null);
						}
					}
				}
				else
				{
					//link the smallest node's left to temp's left child
					l.setLeft(temp.getLeft());
					if(smallestParent.getLeft() != null && 
					   valueOf(smallestParent.getLeft().getValue())
					   == valueOf(l.getValue()))
					{
						smallestParent.setLeft(null);
					}
					if(smallestParent.getRight() != null && 
					   valueOf(smallestParent.getRight().getValue())
					   == valueOf(l.getValue()))
					{
						smallestParent.setRight(null);
					}
					l.setRight(temp.getRight());
					//if temp is on the parent's left set the 
					//parent's left to l
					if(parent.getLeft() != null && 
					   valueOf(parent.getLeft().getValue()) == v)
					{
						searchParentNode(c).setLeft(l);
					}
					//if temp is on the parent's right set the parent's 
					//right to l
					if(parent.getRight() != null && 
					   valueOf(parent.getRight().getValue()) == v)
					{
						searchParentNode(c).setRight(l);
					}
				}
			return;
			}
			//if temp is not myRoot and has no children	
			else if(temp.getLeft() == null && temp.getRight() == null)
			{
				//if temp is on the parent's left set the parent's 
				//left to null
				if(parent.getLeft() != null && valueOf(parent.getLeft()
				   .getValue()) == v)
				{
					searchParentNode(c).setLeft(null);
				}
				//if temp is on the parent's right set the parent's 
				//right to null
				if(parent.getRight() != null && valueOf(parent.getRight()
				   .getValue()) == v)
				{
					searchParentNode(c).setRight(null);
				}
			}
			//if temp is not myRoot and has one child	
			else if(temp.getLeft() != null || temp.getRight() != null)
			{
				//if temp has a left child and is on its parent's left
				//set temp's left child to its parent's left
				if(temp.getLeft() != null && temp == parent.getLeft())
				{
					searchParentNode(c).setLeft(temp.getLeft());
				}
				//if temp has a left child and is on its parent's right
				//set temp's left child to its parent's right
				else if(temp.getLeft() != null && temp == 
						parent.getRight())
				{
					parent.setRight(temp.getLeft());
				}
				//if temp has a right child and is on its parent's left
				//set temp's right child to its parent's left
				else if(temp.getRight() != null && temp == 
						parent.getLeft())
				{
					searchParentNode(c).setLeft(temp.getRight());
				}
				//if temp has a right child and is on its parent's right
				//set temp's right child to its parent's right
				else if(temp.getRight() != null && temp == 
						parent.getRight())
				{
					searchParentNode(c).setRight(temp.getRight());
				}
			}
		}			
	}
    
    /**
     * returns the double value of the Comparable c if it 
     * is a recognized class. If not returns a specific value
     * in place of null
     */
    public double valueOf(Comparable c) 
    {
    	if(c == null) {return -2000000.0003467387;}
		double rval = 0.0;
		if(c.getClass() == Double.class){
			rval = (double)c;
		}
		else if(c.getClass() == Float.class){
			rval = (double)(float) c;
		}
		else if(c.getClass() == Integer.class){
			rval = (double)(int)c;
		}
		else if(c.getClass() == String.class){
			((String) c).replaceAll("\\s+","");
			try { rval = Integer.parseInt((String) c);}
			catch (Exception e) 
			{
				double sum = 0.0;
				for (char v : ((String) c).toCharArray()) {
					sum += v;
				}
				rval = sum;
			}
		}
		else if(c.getClass() == Long.class) {
			rval = (double)(long)c;
		}
		else if(c.getClass() == Short.class) {
			rval = (double)(short)c;
		}
		else if(c.getClass() == Byte.class) {
			rval = (double)(byte)c;
		}
		else if(c.getClass() == Character.class) {
			rval = (double)(char)c;
		}
		else if(c.getClass() == Boolean.class) {
			if(c == (Boolean)true) {rval = 1;}
			else {rval = 0;}
		}
		else{ 
			return -2000000.0003467387;
		}
		return rval;
    }
	
	/**
	 * Returns a TreeNode with a given value
	 */
    public TreeNode searchNode(Comparable c) 
    {
		return searchNode(c, myRoot);
    }
	
    /**
     * private helper method that returns a TreeNode with a given value
     */
	private TreeNode searchNode(Comparable c, TreeNode root)
	{
		double v = valueOf(c);
		if(valueOf(c) == -2000000.0003467387) {return null;}
		if (root != null && valueOf(root.getValue()) == v)
		{
			return root;
		}
		if (root != null && v < valueOf(root.getValue())
		    && myRoot != null) {
			return searchNode(c, root.getLeft());
		} 
		
		if (root != null && v > valueOf(root.getValue()) 
			&& myRoot != null)
		{
			return searchNode(c, root.getRight());
		}
		return root;
	}
	
	/**
	 * returns the smallest node in the tree
	 */
    private TreeNode getSmallest(TreeNode root)
    {
    	if(root == null)
    	{
    		return null;
    	}
    	TreeNode temp = root;
    	while(temp.getLeft() != null)
    	{
    		temp = temp.getLeft();
    	}
    	return temp;
    } 
    
    /**
     * searches for a TreeNode's parent node
     */
    public TreeNode searchParentNode(Comparable c) 
    {
		return searchParentNode(c, myRoot);
    }
    
    /**
     * private helper method to return a node's parent node
     */
    private TreeNode searchParentNode(Comparable c, TreeNode root) {
    	double v = valueOf(c);
    	if(valueOf(c) == -2000000.0003467387) {return null;}
    	// check if null then return null 
    	if (root == null || valueOf(root.getValue()) == v) {
    		return null;
    	}
    	// checks if getLeft() or getRight() equals(c) 
    	if ((root.getLeft()  != null && valueOf(root.getLeft()
    	    .getValue())
    		== v) || (root.getRight() != null && 
    		valueOf(root.getRight().getValue()) == v)) {
    		return root;
    	}
    	// if it does not equal c and less than 0 gets the left side 
    	//else gets the right side
    	if (v < valueOf(root.getValue())) {
    		return searchParentNode(c, root.getLeft());
    	} else {
    		return searchParentNode(c, root.getRight());
    	}
    }
	
    /**
     * add method creates and adds a new node to the tree 
     */
    public void add(Comparable cmp) 
    {
    	if(cmp == null) {return;}
		myRoot = add(myRoot, cmp);
    }
    
    /**
    * private helper method for add method
    * if r is null, sets r to new TreeNode with the cmp parameter
    * as its value
    * otherwise, puts it where it belongs
    */
    private TreeNode add(TreeNode r, Comparable cmp) 
    {
		if (r == null) { 
			r = new TreeNode(cmp, null, null);
		}
		else {
			double v = valueOf(cmp);
			if(cmp ==null) {return null;}
			if(valueOf(cmp) == -2000000.0003467387) {return null;}
			if(v < (valueOf(r.getValue()))) {
				r.setLeft(add(r.getLeft(), cmp));
			}
			else {
				r.setRight(add(r.getRight(), cmp));
			}
		}
	    return r;
    }
 
    /**
     * gets the height of the tree
     */
    public int height() {
    	return height(myRoot);
    }
    
    /**
     * private helper method for height method
     * returns the integer value of the height for the tree
     */
    private int height(TreeNode r) {
    	if(r == null) return 0;
    	return 1 + Math.max(height(r.getLeft()), height(r.getRight()));
    }
    
    /**
     * search for a node with a given value
     */
    public boolean search(Comparable c) 
    {
    	if(c == null) {return false;}
		return search(c, myRoot);
    }
    
    /**
     * private helper method for search method
     * return true if the comparable is found, false otherwise
     */
    private boolean search(Comparable c, TreeNode n) 
    {
    	if (n == null) {return false;}
    	double v = valueOf(c);
    	if(v == -2000000.0003467387) {return false;}
    	if(v == valueOf(n.getValue())) {
    		return true;
    	}
    	if(n.getLeft() != null && search(c, n.getLeft())) {
    		return true; 
    	}
    	if(n.getRight() != null && search(c, n.getRight())) {
    		return true; 
    	}
    	return false;
    }
 
    /**
     * toStringPreOrder method
     */
    public String toStringPreOrder() {
    	StringBuilder sb = new StringBuilder();
    	toStringPreOrder(myRoot, sb);
    	return sb.toString();
    }
    
    /**
     * toStringPreOrder private helper method
     */
    private void toStringPreOrder(TreeNode root, StringBuilder sb) {
    	if (root != null) {
            sb.append("(");
            sb.append(root.getValue());
            toStringPreOrder(root.getLeft(), sb);
            toStringPreOrder(root.getRight(), sb);
            sb.append(")");
        }
    }
    
    /**
     * toStringInOrder method
     */
    public String toStringInOrder() {
    	StringBuilder sb = new StringBuilder();
    	toStringInOrder(myRoot, sb);
    	return sb.toString();
    }
    
    /**
     * toStringInOrder private helper method
     */
    private void toStringInOrder(TreeNode root, StringBuilder sb) {
    	if (root != null) {
    		sb.append("(");
            toStringInOrder(root.getLeft(), sb);
            sb.append(root.getValue());
            toStringInOrder(root.getRight(), sb);
            sb.append(")");
        }
    }
}
